---
title: I/O 基础 
layout: post
comments: true
categories:
- I/O 基础 
tags:
- I/O 基础  
---

<img src="/assets/images/20200405-Java-io/day40-powerbook-wx.png" style="zoom:100%"/>
<br/>
所谓的I/O就是**计算机内存和外部设备之间拷贝数据的过程**，这里的设备可以是磁盘、网卡、声卡、xxx。这篇文章我们一起来聊聊I/O中的一些基础知识。

# 知识补充
首先为你介绍讨论I/O时经常会涉及到的一些名词，包括：内核空间、用户空间、内核缓冲区、用户缓冲区、虚拟内存、DMA,掌握这些对理解I/O的执行过程非常有帮助～

## 内核空间(Kernel space)、用户空间(User space)
在Linux中，内核空间(Kernel space)是Linux内核的运行空间，User space 是用户程序的运行空间。为了安全，他们之间是隔离开的，即使用户的程序崩溃了，内核也不受影响。

## 用户缓冲区、内核缓冲区
I/O (input/output) 操作可以理解为是对缓冲区数据的写入和写出操作，这里的缓冲区(buffer)可以分为：内核缓冲区和用户缓冲区。举例来说：读取数据时内核会把数据从内核缓冲区拷贝到用户缓冲区，相反的写数据时，用户进程会先把数据拷贝到用户缓冲区，内核再拷贝到内核缓冲区完成写入操作。
理解缓冲区以及如何处理缓冲区时I/O的基础，进程通过请求操作系统从缓冲区中清空数据（写操作）或向缓冲区中填充数据（读操作）来执行I/0。

> 注意不要把缓冲区和缓存搞混了，缓冲区是buffer，缓存是cache。buffer是未来减少应用程序的调用次数，集中调用，提高系统的性能；cache是将读取过的数据保存起来，重新读取时如果命中就不需要访问硬盘读取了。

<img src="/assets/images/20200405-Java-io/io-process.png" width="70%" alt="I/O执行过程"/>

上图展示了数据块从外部比如硬盘移动到进程的简化逻辑图，大致可以分为以下四个步骤：
* 当进程执行read()操作，要求系统填充其缓冲区。
* 内核想磁盘控制器硬件发出命令以从磁盘获取数据。
* 磁盘通过控制器DMA将数据直接写入内核的内存缓冲区，这一步无需CPU协调。
* 磁盘控制器完成缓冲区填充后，内核会将数据从内核空间的临时缓冲区复制到进程指定的缓冲区中。

## 虚拟内存
虚拟内存是计算机管理内存的一种技术。上面我们讲到一次完整的I/O调用过程中数据需要从内核空间拷贝至用户空间，这个工作看起来是额外的工作。
为什么不告诉磁盘控制器直接将数据放到用户缓冲区中呢？这就是虚拟内存完成的。虚拟内存有两个重要的优点：
* 多个虚拟地址可以引用相同的物理内存位置。
* 虚拟内存空间可能大于可用的实际硬件内存。

通过将内核空间地址映射得到与用户空间中虚拟地址相同的物理地址，DMA硬件（只能访问物理内存地址）可以填充一个缓冲区，该缓冲区同时对内核和用户空间进程可见。

<img src="/assets/images/20200405-Java-io/Virtual-Memory.png" width="70%" alt="虚拟内存"/>


## DMA（直接内存访问）
直接内存访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。在同等程度的处理器负担下，DMA是一种快速的数据传送方式。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。

# I/O模型
  应用程序发起I/O指令调用后，它执行一个系统调用将控制权交给内核。内核一般不直接读取磁盘（或者网卡），而是将内核缓冲区中的数据拷贝到用户缓冲区，若是内核缓冲区中没有数据，内核会把请求加入请求队列中，然后程序挂起，此时内核继续为其他进程提供服务；当数据取到内核缓冲区后，内核会把数据读取到用户的进程中，之后才会通知进程，在不同的IO模型下，在调度和使用缓冲区的方式有所不同，这就是IO模型要解决的问题～ 

<img src="/assets/images/20200405-Java-io/io-model.jpg" width="70%" alt="I/O模型"/>


## 阻塞I/O 
  拿Socke举例，当发出一个不能立即完成的套接字调用时，其进程将被阻塞，阻塞主要是下面三种。
  * connect 阻塞 ： 客户端发起TCP连接请求，客户端会阻塞直到完成TCP建立连接完成三次握手过程。
  * accept阻塞：服务端接收外来连接，如果没有新的连接到达，进程会被挂起，进入阻塞状态。
  * read、write阻塞 : 客户端或服务端在读取数据是，如果缓冲区没有数据，进程就会进入阻塞。

## 非阻塞I/O ()
  * 在I/O读写操作时，缓冲区中有数据就直接返回数据，没有数据返回0，永远不会阻塞。
  * 当所有操作都是非阻塞状态时，我们需要设置一个线程对该操作进行轮询检查。
   
## I/O复用
在非阻塞I/O中提到了，如果是非阻塞模式下需要用户线程轮询检查I/O的状态，但是在大量请求的情况下，这对于CPU来说无疑是一场灾难。
* Linux提供了I/O复用函数 select/poll/epoll 来解决这个问题，应用程序可以通过I/O复用接口向内核注册fd所关注的事件，当关注的事件触发时，通过I/O复用接口的返回值通知到应用程序。
* I/O复用接口可以同时监听多个事件以提高效率。

> pool() 和 select()存在一个相同的缺点，那就是包含大量的文件描述符的数组被整体复制到用户态和内核的地址空间之间，而无论哪些文件描述符是否就绪，它们的开销会随着文件描述符数量增加而线性增大。

## 信号驱动I/O
  信号驱动I/O类似观察者模式，内核就是一个观察者，信号回调时通知。
* 对于TCP来说，信号驱动几乎没有被使用，引文SIGIO信号是一种Unix信号，信号没有附加信息，如果一个信号源有多种产生信号的原因，信号接受者就无法确定究竟发生了什么。而TCP socket生产的信号事件有七种之多，这样应用程序收到SIGIO，根本无从区分处理。

* 信号驱动I/O现在被用在了UDP通讯上，UPD只有一个数据请求事件，这也意味着在正常情况下UDP进程只要捕获SIGIO信号，就调用recvfrom读取到达的数据报。NTP服务就用了这种模型

## 异步I/O
在信号驱动式I/O虽然在等待数据就绪时没有阻塞，但是被通知进行I/O操作还是阻塞的，进程会等待数据从内核空间复制到用户空间中。而异步I/O则是实现了真正的非阻塞I/O。
* 当用户进程发起一个I/O请求操作，系统会告知内核处理某个操作，并让内核在整个操作完成后通知进程。整个操作完成包括等待数据就绪和数据从内核拷贝到用户空间。
* 目前Linux暂不支持，Windows已经实现了异步I/O，所以在实际生产环境中很少用到异步I/O模型。


上面介绍了五种I/O模型，在Java中对这些模型的支持情况，看下表：

| I/O模型	| JDK版本|	说明|
|----------|:-------------:|:------|:------|
| 阻塞I/O(Blocking IO)	| JDK1.4之前(java.io)| 连接数高的情况下:阻塞-->耗资源、效率低 |
| 非阻塞I/O(Non-blocking IO) |	JDK1.4（2002年，java.nio包） 	| 按连接轮询调用，耗资源-->耗资源、效率低 |
| I/O复用(IO Multiplexing)	| JDK1.4（2002年，java.nio包）	| select/poll，JDK1.5 且Linux内核在2.6版本以上NIO中会选择epoll来替代传统的selet/poll，这也极大的提升了NIO的通信性能。|
| 信号驱动I/O|	java中好像没有实现?| 对TCP通信不支持，主要用于UDP通信，比如NTP服务器 |
| 异步I/O(Asynchronous IO-AIO)	| JDK1.7（2011年）	| 1、windows系统实现成熟，但基本不用来做服务器 2、Linux常用来做服务器，但实现不够成熟。3、在Linux下AIO相比较NIO的性能提升不明显。|

上面表格中讲到，在Linux环境下Java的NIO是借助select/poll/epoll来实现的，我们来对着三种不同的多路IO转接技术做一下对比：

|	 | select	| poll|	epoll|
|------|:-------------:|:------|:------|:------|
|操作方式|遍历	|遍历|	回调|
|底层实现|	数组|	链表|	哈希表|
|IO效率|	每次调用都会进行线性遍历，时间复杂度为O(N)|	每次调用都会线性调用，时间复杂度O(N)	| 事件通知，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdlist里面，事件复杂度O(1)|
|最大连接数|	1024(x86) 或 2048(x64) |	无上限	| 无上限 |
|fd拷贝|	每次调用select，都需要把fd集合从用户态拷贝到内核态	| 每次调用poll,都需要把fd集合从用户态拷贝 | 	调用epoll_ctl时拷贝进内核并保存，之后没吃epoll_wait不拷贝|


# 总结
  本篇主要是简单梳理了一下I/O涉及到的一些基础知识，还介绍了5中经典的I/O模型，对这些I/O模型在Java中各个版本下的支持情况做了一个简单的对比，下一篇文章我们一起来学习一下Java中的NIO实现。


## 参考资料
> [User space 与Kernel space - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html) 
> [I/O models](https://notes.shichao.io/unp/ch6/)  
> [网络通信优化之I/O模型](http://gk.link/a/10hRc)  